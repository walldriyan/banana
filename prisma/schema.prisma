// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

// ===================================
// AUTH & USERS
// ===================================
// These models are compatible with NextAuth.js.
// See: https://next-auth.js.org/adapters/prisma

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ===================================
// CORE BUSINESS MODELS
// ===================================

model Company {
  id                 String  @id @default(cuid())
  name               String  @unique
  address            String?
  phone              String? @unique
  email              String? @unique
  registrationNumber String? @unique
  taxNumber          String?
  logoUrl            String?
  isActive           Boolean @default(true)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  financialTransactions FinancialTransaction[]
}


model Product {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  category    String
  brand       String
  units       Json
  isService   Boolean  @default(false)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  batches ProductBatch[]
}

model ProductBatch {
  id              String    @id @default(cuid())
  productId       String
  batchNumber     String
  stock           Int
  quantity        Int
  costPrice       Float?
  sellingPrice    Float
  barcode         String?   @unique
  addedDate       DateTime
  manufactureDate DateTime?
  expiryDate      DateTime?
  location        String?
  notes           String?
  tax             Float?
  taxtype         String?
  discount        Float?
  discountType    String?
  supplierId      String?

  goodsReceivedNoteItem GoodsReceivedNoteItem?

  product         Product          @relation(fields: [productId], references: [id], onDelete: Cascade)
  supplier        Supplier?        @relation(fields: [supplierId], references: [id], onDelete: SetNull)
  lines           TransactionLine[]
  lostAndDamage   LostAndDamage[]

  @@unique([productId, batchNumber])
}

model Supplier {
  id            String   @id @default(cuid())
  name          String   @unique
  contactPerson String?
  phone         String?
  email         String?
  address       String?
  notes         String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  grns                  GoodsReceivedNote[]
  batches               ProductBatch[]
  financialTransactions FinancialTransaction[]
}

model Customer {
  id        String   @id @default(cuid())
  name      String
  phone     String?  @unique
  email     String?
  address   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  transactions          Transaction[]
  financialTransactions FinancialTransaction[]
}

model GoodsReceivedNote {
  id            String   @id @default(cuid())
  grnNumber     String   @unique
  grnDate       DateTime
  supplierId    String
  invoiceNumber String?
  totalAmount   Float
  paidAmount    Float    @default(0)
  paymentStatus String   @default("pending") // pending, partial, paid
  notes         String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  paymentMethod String   @default("credit")

  supplier Supplier                @relation(fields: [supplierId], references: [id], onDelete: Restrict)
  items    GoodsReceivedNoteItem[]
  payments PurchasePayment[]
}

model GoodsReceivedNoteItem {
  id             String       @id @default(cuid())
  grnId          String
  productBatchId String       @unique
  quantity       Int
  costPrice      Float
  discount       Float        @default(0)
  tax            Float        @default(0)
  total          Float
  discountType   String?
  taxType        String?

  grn          GoodsReceivedNote @relation(fields: [grnId], references: [id], onDelete: Cascade)
  productBatch ProductBatch      @relation(fields: [productBatchId], references: [id], onDelete: Restrict)
}


model PurchasePayment {
  id                  String   @id @default(cuid())
  goodsReceivedNoteId String
  amount              Float
  paymentDate         DateTime
  paymentMethod       String // cash, card, cheque, online
  notes               String?
  createdAt           DateTime @default(now())

  grn GoodsReceivedNote @relation(fields: [goodsReceivedNoteId], references: [id], onDelete: Cascade)
}


model Transaction {
  id                    String    @id @default(cuid())
  transactionDate       DateTime
  customerId            String
  subtotal              Float
  totalDiscountAmount   Float
  finalTotal            Float
  totalItems            Int
  totalQuantity         Float
  status                String // completed, refund, pending
  campaignId            String
  isGiftReceipt         Boolean?
  originalTransactionId String?   @unique
  paymentStatus         String    @default("pending") // pending, partial, paid
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  customer          Customer           @relation(fields: [customerId], references: [id], onDelete: Restrict)
  payment           Payment?
  lines             TransactionLine[]
  appliedDiscounts  AppliedDiscount[]
  originalTransaction   Transaction?       @relation("Refund", fields: [originalTransactionId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  refundTransactions  Transaction[]      @relation("Refund")
  salePayments      SalePayment[]
}

model Payment {
  id                String   @id @default(cuid())
  transactionId     String   @unique
  paidAmount        Float
  paymentMethod     String // cash, card, online
  outstandingAmount Float
  isInstallment     Boolean
  createdAt         DateTime @default(now())

  transaction Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
}

model SalePayment {
  id            String   @id @default(cuid())
  transactionId String
  amount        Float
  paymentDate   DateTime
  paymentMethod String // cash, card, cheque, online
  notes         String?
  createdAt     DateTime @default(now())

  transaction Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
}


model TransactionLine {
  id                      String   @id @default(cuid())
  transactionId           String
  productBatchId          String
  productName             String
  batchNumber             String?
  quantity                Float // Using Float to support fractional quantities (e.g., 0.5 kg)
  displayUnit             String
  displayQuantity         Float
  unitPrice               Float
  lineTotalBeforeDiscount Float
  lineDiscount            Float
  lineTotalAfterDiscount  Float
  customDiscountValue     Float?
  customDiscountType      String?
  customApplyFixedOnce    Boolean?

  transaction  Transaction  @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  productBatch ProductBatch @relation(fields: [productBatchId], references: [id], onDelete: Restrict)
}

model AppliedDiscount {
  id                      String   @id @default(cuid())
  transactionId           String
  discountCampaignName    String
  sourceRuleName          String
  totalCalculatedDiscount Float
  ruleType                String
  productIdAffected       String?
  batchIdAffected         String?
  appliedOnce             Boolean?

  transaction Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
}

model DiscountSet {
  id                                  String   @id @default(cuid())
  name                                String   @unique
  description                         String?
  isActive                            Boolean  @default(true)
  isDefault                           Boolean  @default(false)
  isOneTimePerTransaction             Boolean  @default(false)
  validFrom                           DateTime?
  validTo                             DateTime?
  
  // JSON fields to store rule configurations
  globalCartPriceRuleJson             Json?
  globalCartQuantityRuleJson          Json?
  defaultLineItemValueRuleJson        Json?
  defaultLineItemQuantityRuleJson     Json?
  defaultSpecificQtyThresholdRuleJson Json?
  defaultSpecificUnitPriceThresholdRuleJson Json?

  createdAt                           DateTime @default(now())
  updatedAt                           DateTime @updatedAt
}

model FinancialTransaction {
  id          String   @id @default(cuid())
  date        DateTime
  type        String // INCOME or EXPENSE
  amount      Float
  description String
  category    String
  companyId   String
  customerId  String?
  supplierId  String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  company  Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  customer Customer? @relation(fields: [customerId], references: [id], onDelete: SetNull)
  supplier Supplier? @relation(fields: [supplierId], references: [id], onDelete: SetNull)
}

model LostAndDamage {
  id              String   @id @default(cuid())
  date            DateTime
  productBatchId  String
  quantity        Float
  reason          String // DAMAGED, LOST, EXPIRED, OTHER
  notes           String?
  createdAt       DateTime @default(now())

  productBatch    ProductBatch @relation(fields: [productBatchId], references: [id], onDelete: Restrict)
}
