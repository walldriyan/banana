// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  // The `binaryTargets` setting is needed to run Prisma Client in an environment
  // that is different from the one in which it was generated (e.g. Docker).
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

// Full-text search is not supported by SQLite.
// We are using a workaround with a separate model for now.

// MODELS

model Product {
  id                    String      @id @default(cuid())
  name                  String // e.g., "Dell Inspiron 15"
  productId             String // General ID for the product type, e.g. "P001"
  batchNumber           String? // e.g., "B001"
  sellingPrice          Float
  costPrice             Float?
  quantity              Int // Current stock level
  stock                 Int
  barcode               String?     @unique // SKU
  category              String? // e.g., "Laptops"
  brand                 String? // e.g., "Dell"
  supplierId            String?
  location              String? // e.g., "Warehouse A, Shelf B-3"
  units                 String // JSON string to store unit definitions
  isService             Boolean     @default(false)
  isActive              Boolean     @default(true)
  defaultQuantity       Int         @default(1)
  tax                   Float?
  taxtype               String? // "FIXED" or "PERCENTAGE"
  defaultDiscount       Float?
  defaultDiscountType   String? // "FIXED" or "PERCENTAGE"
  manufactureDate       DateTime?
  expiryDate            DateTime?
  minStockLevel         Int?
  maxStockLevel         Int?
  notes                 String?
  status                String?
  addeDate              DateTime    @default(now())
  userId                String?
  companyId             String?

  transactionLines      TransactionLine[]

  @@unique([productId, batchNumber])
}

model Transaction {
  id                    String                @id
  transactionDate       DateTime
  subtotal              Float
  totalDiscountAmount   Float
  finalTotal            Float
  totalItems            Int
  totalQuantity         Float
  status                String // "completed", "refund", "pending"
  campaignId            String
  isGiftReceipt         Boolean               @default(false)
  
  customerId            Int
  customer              Customer              @relation(fields: [customerId], references: [id])
  
  payment               Payment?
  lines                 TransactionLine[]
  appliedDiscounts      AppliedDiscountLog[]

  // Self-relation for refunds
  originalTransactionId String?
  originalTransaction   Transaction?          @relation("RefundToOriginal", fields: [originalTransactionId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  refundTransactions    Transaction[]         @relation("OriginalToRefunds")
}

model Customer {
  id          Int      @id @default(autoincrement())
  name        String
  phone       String?  @unique
  address     String?
  
  transactions Transaction[]
}

model Payment {
  id                  Int      @id @default(autoincrement())
  paidAmount          Float
  paymentMethod       String // "cash", "card", "online"
  outstandingAmount   Float
  isInstallment       Boolean
  
  transactionId       String   @unique
  transaction         Transaction @relation(fields: [transactionId], references: [id])
}

model TransactionLine {
  id                        Int       @id @default(autoincrement())
  productId                 String // General Product ID from Product model
  productName               String
  batchId                   String? // Specific unique ID from Product model
  batchNumber               String?
  quantity                  Float
  displayUnit               String
  displayQuantity           Float
  unitPrice                 Float
  lineTotalBeforeDiscount   Float
  lineDiscount              Float
  lineTotalAfterDiscount    Float
  customDiscountValue       Float?
  customDiscountType        String?
  customApplyFixedOnce      Boolean?
  
  transactionId             String
  transaction               Transaction @relation(fields: [transactionId], references: [id])

  product                   Product @relation(fields: [batchId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  @@index([transactionId])
}

model AppliedDiscountLog {
  id                        Int    @id @default(autoincrement())
  discountCampaignName      String
  sourceRuleName            String
  totalCalculatedDiscount   Float
  ruleType                  String
  productIdAffected         String?
  batchIdAffected           String?
  appliedOnce               Boolean?
  
  transactionId             String
  transaction               Transaction @relation(fields: [transactionId], references: [id])

  @@index([transactionId])
}
